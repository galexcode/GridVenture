


/// this will print to the screen each material in each cell.
void generate_grid_surface(SDL_Surface *surfaceToPrintTo){
    
    int i,j;
	SDL_Rect myRectangleMat;
	// constant cell sizes
	myRectangleMat.w = CELL_SIZE;
	myRectangleMat.h = CELL_SIZE;
	
	//this is the upper corner of where the screen starts displaying grid data.
	int i_start = (int)( (player.x_pos) - GRID_WIDTH/2  );
	int j_start = (int)( (player.y_pos) - GRID_HEIGHT/2 );
	
	// these are for indexing into the grid
	int ig,jg;
	//these are how far off the grid the player is.
	//float adjust_x = -(player.x_pos - ((int)player.x_pos) )*CELL_SIZE;
	//float adjust_y = -(player.x_pos - ((int)player.x_pos) )*CELL_SIZE;
	
	// print out the grid
	for(i = 0; i <= GRID_WIDTH; i++){
		// this is used to index into the grid
		ig = i+i_start;
		if(ig < 0) continue; // if ig is less than the minimum bound, make it equal to the minimum array index value.
		if(ig >= GRID_WIDTH_ELEMENTS) break; // if ig is larger than the largest array index value, quit.
        for(j = 0; j <= GRID_HEIGHT; j++){
        	// this is used to index into the grid
			jg = j+j_start;
			if(jg < 0) continue; // if jg is less than the minimum bound, make it equal to the minimum bound
			if(jg >= GRID_HEIGHT_ELEMENTS) break; // if jg is larger than the largest array index, quit.
			
        	//only print the material if it is not air
			if(grid[ig][jg].mat != m_air){
				myRectangleMat.x = i*CELL_SIZE;
				myRectangleMat.y = j*CELL_SIZE;
				SDL_FillRect( surfaceToPrintTo , &myRectangleMat , mats[grid[ig][jg].mat].color);
			}
        }
    }
}



#define grad_linear 0
#define grad_radial 1

void gradient(SDL_Surface *datsurface, SDL_Rect *gradClip, int x1, int y1, int x2, int y2, Uint32 color1, Uint32 color2, unsigned int gradientType){
	
	// this is the integer used for the color of (i,j) pixel in the gradient
	long unsigned int color;
	// these are all one-time calculations. these values will be used in the loop.
	unsigned int alp1 = color1/0x1000000;
	unsigned int red1 = (color1/0x10000)%0x100;
	unsigned int gre1 =(color1/0x100)%0x100;
	unsigned int blu1 = color1%0x100;
	unsigned int alp2 = color2/0x1000000;
	unsigned int red2 = (color2/0x10000)%0x100;
	unsigned int gre2 =(color2/0x100)%0x100;
	unsigned int blu2 = color2%0x100;
	
	// this is for displaying the pixel at (i,j)
	SDL_Rect pixelRect;
	pixelRect.w = 1;
	pixelRect.h = 1;
	
	// y = mx + b
	// this if for the line connecting points (x1,y1) and (x2,y2)
	// calculate the slope of the line. rise/run
	float m_original = ((float)(y2-y1))/((float)(x2-x1));
	
	//this is for the lines perpendicular to the original line. it is -1/original_slope.
	//this is the slope that will be used when calculating the color of each pixel
	float m = -1.0f/m_original;
	
	float b1 = y1 - m*x1;		// rearranged form of  y = mx + b  to calculate the the y-intercept for b1 
	float b2 = y2 - m*x2;		// similar shenanigans for b2
	float bdiff = b2 - b1;		// calculate the difference in the y-intercept terms
	float b;					// this is the intercept of the pixel at (i,j)
	
	int i,j; // variables used to loop through the columns and row respectively.
		for(i=gradClip->x; i<gradClip->x+gradClip->w; i++){		// loop through the columns of the gradient clip
		for(j=gradClip->y; j<gradClip->y+gradClip->h; j++){	// loop through the rows    of the gradient clip
			pixelRect.x = i;
			pixelRect.y = j;
			b = (float)j - m*(float)i; // calculate y-intercept for this point (i,j)
			if(b < b1) 			// the pixel is not between the two points
				color = color1;	// choose color1
			else if( b > b2) 	// the pixel is not between the two points
				color = color2; // choose color2
			else{
				color = (int)((alp1*(b2-b) + alp2*(b-b1))/bdiff)*0x1000000;	// calculate alpha color component
				color+= (int)((red1*(b2-b) + red2*(b-b1))/bdiff)*0x10000;	// calculate red   color component
				color+= (int)((gre1*(b2-b) + gre2*(b-b1))/bdiff)*0x100;		// calculate green color component
				color+= (int)((blu1*(b2-b) + blu2*(b-b1))/bdiff);			// calculate blue  color component
			}
			SDL_FillRect(datsurface, &pixelRect, color);
			
		}
	}
}


void generate_sky(SDL_Surface *datsurface, int width, int height){
	
	SDL_Rect screenRect;
	screenRect.x = 0;
    screenRect.y = 0;
    screenRect.w = width;
    screenRect.h = height;
    
    SDL_FillRect(datsurface, &screenRect, 0); // blank the sky
    gradient(datsurface, &screenRect, 0, 0, 1, height, 0xff172092, 0xff6cb8f6, 0);
}


void print_debugging_information(int mousex, int mousey){
	//----------------------------------------------------
	// PRINT PLAYER POSITION INFORMATION
	//----------------------------------------------------
	static char textMessage[100]; // this holds the string that tells you what the player's position is.
	static char textDummy[100]; // this holds misc text values generated by the itoa() function.
	
	static SDL_Surface *textSurface;
	static SDL_Color white;
	white.r = white.g = white.b = 0xff; // set white color
	
	strcpy(textMessage,"x_pos=");						// "x_pos="
	itoa((int)player.x_pos,textDummy,10);				// generate integer portion of x pos in string form
	strcat(textMessage,textDummy);						// "x_pos=1234"
	strcat(textMessage,".");								// "x_pos=1234."
	itoa(((int)(player.x_pos*1000))%1000,textDummy,10);	// generate the first three decimal places of x_pos
	strcat(textMessage,textDummy);						// "x_pos=1234.567"
	
	textSurface = TTF_RenderText_Blended(font16,textMessage, white);	// render text
	apply_surface(3, -7, textSurface, screen);							// apply text
	SDL_FreeSurface(textSurface);
	
	strcpy(textMessage," y_pos=");						// "y_pos="
	itoa((int)player.y_pos,textDummy,10);				// generate integer portion of y_pos in string form
	strcat(textMessage,textDummy);						// "y_pos=1234"
	strcat(textMessage,".");								// "y_pos=1234."
	itoa(((int)(player.y_pos*1000))%1000,textDummy,10);	// generate the first three decimal places of y_pos
	strcat(textMessage,textDummy);						// "y_pos=1234.567"
	
	
	textSurface = TTF_RenderText_Blended(font16,textMessage, white);	// render text
	apply_surface(145, -7, textSurface, screen);							// apply text
	SDL_FreeSurface(textSurface);
	//----------------------------------------------------
	// PRINT MOUSE LOCATION INFO
	//----------------------------------------------------
	strcpy(textMessage, "x=");							// "x="
	itoa(mousex, textDummy, 10);						// generate string of the mousex value
	strcat(textMessage, textDummy);						// "x=1920"
	
	textSurface = TTF_RenderText_Blended(font16,textMessage, white);	// render text
	apply_surface(300, -7, textSurface, screen);						// apply text
	SDL_FreeSurface(textSurface);
	
	strcpy(textMessage, "y=");							// "y="
	itoa(mousey, textDummy, 10);						// generate string of the mousey value
	strcat(textMessage, textDummy);						// "y=1080"
	
	textSurface = TTF_RenderText_Blended(font16,textMessage, white);	// render text
	apply_surface(372, -7, textSurface, screen);						// apply text
	SDL_FreeSurface(textSurface);
	//----------------------------------------------------
	// PRINT TICKS and FPS INFORMATION
	//----------------------------------------------------
	strcpy(textMessage, "Ticks=");						// "Ticks="
	itoa(SDL_GetTicks(), textDummy, 10);				// generate string of the number of ticks
	strcat(textMessage, textDummy);						// "Ticks=123456789"
	
	textSurface = TTF_RenderText_Blended(font16,textMessage, white);	// render text
	apply_surface(100, 13, textSurface, screen);						// apply text
	SDL_FreeSurface(textSurface);
	
	strcpy(textMessage, "FPS=");									// "FPS="
	itoa(FPS, textDummy, 10);										// generate string of the current FPS
	strcat(textMessage, textDummy);									// "FPS=31"
	textSurface = TTF_RenderText_Blended(font16,textMessage, white);// render text
	apply_surface(3, 13, textSurface, screen);						// apply text
	SDL_FreeSurface(textSurface);
	//----------------------------------------------------
	// PRINT onCollMat value of the player
	//----------------------------------------------------
	strcpy(textMessage,"onCollMat=");
	if(player.onCollMat)
		strcat(textMessage,"1");
	else
		strcat(textMessage,"0");
	textSurface = TTF_RenderText_Blended(font16,textMessage, white);	// render text
	apply_surface(3, 33, textSurface, screen);						// apply text
	SDL_FreeSurface(textSurface);
}




//this draws a line on the screen from point (x1,y1) to point (x2,y2)
// this draws the line (mathematically) from the centers of the two pixels.
void draw_line(SDL_Surface *theSurface, int x1, int y1, int x2, int y2, int thickness, int lineColor){
	//this is the rectangle describing the pixel to color in.
	SDL_Rect myPixel;
	myPixel.w = 1;
	myPixel.h = 1;
	
	//handle lines with no x-difference
	if(x1 == x2){
		// this handles the special case that the line is a point
		if(y1 == y2){
			// draw a point
			myPixel.x = x1;
			myPixel.y = y1;
			SDL_FillRect(theSurface, &myPixel, lineColor);
			// done drawing a point. that's all folks!
			return;
		}
		//this handles the special case the the line is a verticle line (slope infinity)
		// this swaps the x and y values so that the function draws a line with a finite slope (zero)
		draw_line(theSurface,y1,x1,y2,x2,thickness,lineColor);
		return;
	}
	
	float slope = (float)(y2-y1)/(float)(x2-x1);
	//generate an absolute value of the slope
	float absval_slope = slope;
	if(slope < 1) absval_slope *= -1;
	float x,y;
	//this is used to mathematically determine where the line should be.
	float line_value;
	
	// if the absolute value of the slope is less than 1, index through the x values
	if(absval_slope < 1){
		/* OLD CODE FOR GRADUAL SLOPE LINES
		// swap the points around if x1 > x2
		if(x1 > x2){
			
			int tempval=x1;	// store x1
			x1 = x2;		// put x2 into x1
			x2 = tempval;	// put the value that used to be in x1 into x2.
			tempval = y1;	// store y1
			y1 = y2;		// put y2 into y1
			y2 = tempval;	// put the value that used to be in y1 into y2.
		}
		
		for(x=x1+0.5,myPixel.x=x1; x<x2; x+=1.0,myPixel.x++){
			line_value = slope*x +y1;
			myPixel.y = line_value; // integer assignment. truncate decimal places
			// if the line_value has decimal place value greater than or equal to 0.5, then round up.
			if(line_value-(int)line_value >= 0.5) myPixel.y++;
				
			SDL_FillRect(theSurface, &myPixel, lineColor);
		}
		*/
		//all of this assumes that x1 <= x2
		float pixel_offset = 0.5;
		//x2 is greater than x1
		int low_x = x1;
		int high_x = x2;
		int ref_y = y1;		// this is the reference y. this is where we start
		
		// this takes care of the special case of x1 being bigger than x2.
		if(x1 > x2){
			pixel_offset *= -1;
			//x2 is less than x1
			low_x = x2;
			high_x = x1;
			ref_y = y2;
		}
		
		
		for(x=low_x+pixel_offset,myPixel.x=low_x; x<high_x; x+=1,myPixel.x++){
			line_value = (x-low_x)*slope + ref_y;
			myPixel.y = line_value; // integer assignment. truncate decimal places
			// if the line_value has decimal place value greater than or equal to 0.5, then round up.
			if(line_value-(int)line_value > 0.5) myPixel.y++;
				
			SDL_FillRect(theSurface, &myPixel, lineColor);
		}
	}
	// otherwise, the absolute value of the slope is greater to or equal to one, so index through the y values
	else{
		/*
		// swap the points around if y1 > y2
		if(x1 > x2){
			int tempval=x1;	// store x1
			x1 = x2;		// put x2 into x1
			x2 = tempval;	// put the value that used to be in x1 into x2.
			tempval = y1;	// store y1
			y1 = y2;		// put y2 into y1
			y2 = tempval;	// put the value that used to be in y1 into y2.
		}
		*/
		
		
		//all of this assumes that y1 <= y2
		float pixel_offset = 0.5;
		//y2 is greater than y1
		int low_y = y1;
		int high_y = y2;
		int ref_x = x1;		// this is the reference x. this is where we start
		
		// this takes care of the special case of y1 being bigger than y2.
		if(y1 > y2){
			pixel_offset *= -1;
			//y2 is less than y1
			low_y = y2;
			high_y = y1;
			ref_x = x2;
		}
		
		
		for(y=low_y+pixel_offset,myPixel.y=low_y; y<high_y; y+=1,myPixel.y++){
			line_value = (y-low_y)/slope + ref_x;
			myPixel.x = line_value; // integer assignment. truncate decimal places
			// if the line_value has decimal place value greater than or equal to 0.5, then round up.
			if(line_value-(int)line_value > 0.5) myPixel.x++;
				
			SDL_FillRect(theSurface, &myPixel, lineColor);
		}
	}
	
}




